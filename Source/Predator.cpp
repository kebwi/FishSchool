#include "Predator.h"#include "Prey.h"#include "Random.h"#include "MathStuff.h"#include "smallStructs.h"#include <iostream>#include <vector>#include <algorithm>	//for min/max#include <utility>	//for pair<>using namespace std;//======================================================================//Constsconst GLfloat Predator::skMaxPredatorHungerFrustration = .9;const float Predator::skMaterialColor[]	 = {0.5f, 0.0f, 0.5f, 1.0f};//======================================================================//Extern Global variablesextern Settings gSettings;//======================================================================//Global variablesint Predator::sMaxNeighborsPredator = 1;GLfloat Predator::sPredatorHungerStrength = 5.0;//======================================================================//Function prototypesvoid checkError(GLint status, const char *msg);void quit();void quitWithMsg(const char* msg);//======================================================================Predator::Predator() : Agent(){	_predatorHungerFrustration = 0.0;		_secsSinceLastFeeding = 0.0;		_color[0] = skMaterialColor[0] + RandZeroFloat(.5);	Constrain(0.0, _color[0], 1.0);	_color[1] = skMaterialColor[1];	_color[2] = skMaterialColor[2] + RandZeroFloat(.5);	Constrain(0.0, _color[2], 1.0);		_speed = 1.0;		vecSetLength(_desiredVel, _speed * gSettings.speedScalar);}Predator::~Predator(){}void Predator::draw(){	//Note that the following test will not work properly if the camera is rotated.	//However, doing a Z-test and then setting alpha to 0 when behind the camera in the vertex shader	//runs very slow when fog is turned on, which occurs in the fragment shader.  I don't know why.	if (_loc[2] > 0.0)		return;	//Agent is behind the camera		float materialColor[4] = { 0, 0, 0, 1 };	for (int j = 0; j < 4; j++)		materialColor[j] = skMaterialColor[j];		if (gSettings.showFrustration)	{		switch (_dominantFrustrationType)		{			case Agent::DRIVE_COW:				materialColor[0] = 1.0;				materialColor[1] = 0.0;				materialColor[2] = 0.0;				break;			case Agent::DRIVE_N_COG:				materialColor[0] = 0.0;				materialColor[1] = 1.0;				materialColor[2] = 0.0;				break;			case Agent::DRIVE_N_VEL:				materialColor[0] = 0.0;				materialColor[1] = 0.0;				materialColor[2] = 1.0;				break;			case Agent::DRIVE_AVOID:				materialColor[0] = 1.0;				materialColor[1] = 1.0;				materialColor[2] = 0.0;				break;			case Agent::DRIVE_COG:				quitWithMsg("Dominant predator drive cog");				break;			case Agent::DRIVE_NN_DIST:				materialColor[0] = 1.0;				materialColor[1] = 0.0;				materialColor[2] = 1.0;				break;			case Agent::DRIVE_EVADE:				materialColor[0] = 0.0;				materialColor[1] = 1.0;				materialColor[2] = 1.0;				break;			case Agent::DRIVE_HUNGER:				materialColor[0] = 0.0;				materialColor[1] = 1.0;				materialColor[2] = 0.5;				break;		}		glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, materialColor);	}	else glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, _color);		if (!gSettings.useShader)	{		glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, skMaterialSpecular);		glMaterialf(GL_FRONT, GL_SHININESS, skMaterialShininess);	}		glPushMatrix();				//Rotate camera		glRotatef(gSettings.cameraYaw, 0.0, 1.0, 0.0);		glRotatef(gSettings.cameraPitch, 1.0, 0.0, 0.0);		glRotatef(gSettings.cameraPitch, 0.0, 0.0, 1.0);				//Move to location		glTranslatef(_loc[0], _loc[1], _loc[2]);				//Rotate the agent to point toward the direction of travel		GLfloat v1[3] = { 0.0, 0.0, 1.0 };		bool zeroLen = vecNormalize(v1);		GLfloat v2[3] = { _actualVel[0], _actualVel[1], _actualVel[2] };		zeroLen = vecNormalize(v2);				GLfloat axis[3] = { 0 };		vecCross(v1, v2, axis);		zeroLen = vecNormalize(axis);				GLfloat angleToVel = acos(vecDot(v1, v2));		if (isnan(angleToVel))		{			GLfloat v1a[3] = { v1[0], v1[1], v1[2] };			vecSetLength(v1a, .999);			GLfloat v2a[3] = { v2[0], v2[1], v2[2] };			vecSetLength(v2a, .999);						angleToVel = acos(vecDot(v1a, v2a));			//cout << "Attempted to fix nan acos() in draw() A" << endl;		}				glRotatef(RadToDeg(angleToVel), axis[0], axis[1], axis[2]);				//Find the distance from the origin (and thus from the camera)		float distInv = max(gSettings.worldBounds - vecLength(_loc), 0.0f);				int coneSections = 16, torusSections = 4;		//int coneSections = 32, torusSections = 8;	//Super hi resolution				if (gSettings.distanceVertexComplexityScalingEnabled)		{			coneSections = (int)(distInv * .6 + 4.01);			Truncate(4, coneSections, 16);						torusSections = (int)(distInv * .05 + 3.01);			Truncate(3, torusSections, 4);		}				glScalef(2.0, 2.0, 2.0);				//Body and tail		glPushMatrix();			glScalef(1.0, .25, 1.0);			glTranslatef(0.0, 0.0, -1.25);			glutSolidCone(.5, 2.5, coneSections, 1);	//Body			glTranslatef(0.0, 0.0, -.25);			if (gSettings.bodyAnimationEnabled)				glRotatef(_tailPos * 20.0, 1.0, 0.0, 0.0);			glutSolidCone(.5, .5, coneSections, 1);	//Tail		glPopMatrix();				//Fin		glPushMatrix();			glTranslatef(0.0, 0.2, -0.75);			if (gSettings.bodyAnimationEnabled)				glRotatef(_tailPos * 30.0, 0.0, 1.0, 0.0);			glRotatef(90.0, 0.0, 1.0, 0.0);			//glutWireTorus(.1, .3, torusSections, 3);			glutSolidTorus(.1, .3, torusSections, 3);		glPopMatrix();				//Fin		glPushMatrix();			glRotatef(180.0, 0.0, 0.0, 1.0);			glTranslatef(0.0, 0.2, -0.75);			if (gSettings.bodyAnimationEnabled)				glRotatef(-_tailPos * 30.0, 0.0, 1.0, 0.0);			glRotatef(90.0, 0.0, 1.0, 0.0);			//glutWireTorus(.1, .3, torusSections, 3);			glutSolidTorus(.1, .3, torusSections, 3);		glPopMatrix();				//Fin		glPushMatrix();			glTranslatef(0.0, 0.1, .25);			if (gSettings.bodyAnimationEnabled)				glRotatef(-_tailPos * 30.0, 0.0, 1.0, 0.0);			glRotatef(90.0, 0.0, 1.0, 0.0);			//glutWireTorus(.067, .2, torusSections, 3);			glutSolidTorus(.067, .2, torusSections, 3);		glPopMatrix();				//Fin		glPushMatrix();			glRotatef(180.0, 0.0, 0.0, 1.0);			glTranslatef(0.0, 0.1, .25);			if (gSettings.bodyAnimationEnabled)				glRotatef(_tailPos * 30.0, 0.0, 1.0, 0.0);			glRotatef(90.0, 0.0, 1.0, 0.0);			//glutWireTorus(.067, .2, torusSections, 3);			glutSolidTorus(.067, .2, torusSections, 3);		glPopMatrix();			glPopMatrix();}void Predator::update(int idx, vector<Prey*> prey, vector<Predator*> predators, GLfloat preyCog[3], double secsTranspired){	_stateColor[0] = _stateColor[1] = _stateColor[2] = 0.0;		//Find the single closest agent of either species (for avoidance),	//the single closest prey (for hunting),	//and the closest group of neighbors of the matching species (for flocking)	GLfloat minAgentDistLoc[3] = { 0, 0, 0 };	GLfloat minAgentDistSquared = 999999.0;	GLfloat minPreyDistLoc[3] = { 0, 0, 0 };	GLfloat minPreyDistSquared = 999999.0;	AgentType closestAgentType = UNKNOWN;		//Init a vector that will be filled with the closest predators	vector<pair<Predator*, GLfloat> > closestNeighbors;	for (int j = 0; j < sMaxNeighborsPredator; j++)		closestNeighbors.push_back(pair<Predator*, GLfloat>(NULL, 999999.0));		//Find the closest prey	for (int j = 0; j < gSettings.numPrey; j++)	{		GLfloat v[3] = { prey[j]->_loc[0] - _loc[0], prey[j]->_loc[1] - _loc[1], prey[j]->_loc[2] - _loc[2] };		GLfloat distSquared = vecLengthSquared(v);		if (distSquared < Agent::skMaxOtherAgentDetectDistSquared)		{			if (distSquared < minAgentDistSquared)			{				minAgentDistLoc[0] = prey[j]->_loc[0];				minAgentDistLoc[1] = prey[j]->_loc[1];				minAgentDistLoc[2] = prey[j]->_loc[2];				minAgentDistSquared = distSquared;				closestAgentType = PREY;			}						if (distSquared < minPreyDistSquared)			{				minPreyDistLoc[0] = prey[j]->_loc[0];				minPreyDistLoc[1] = prey[j]->_loc[1];				minPreyDistLoc[2] = prey[j]->_loc[2];				minPreyDistSquared = distSquared;			}		}	}		//Find the closest predators and insert them into the vector	for (int j = 0; j < gSettings.numPredators; j++)		if (j != idx)		{			GLfloat v[3] = { predators[j]->_loc[0] - _loc[0], predators[j]->_loc[1] - _loc[1], predators[j]->_loc[2] - _loc[2] };			GLfloat distSquared = vecLengthSquared(v);			if (distSquared < 400.0)//Agent::skMaxOtherAgentDetectDistSquared)			{				if (distSquared < minAgentDistSquared)				{					minAgentDistLoc[0] = predators[j]->_loc[0];					minAgentDistLoc[1] = predators[j]->_loc[1];					minAgentDistLoc[2] = predators[j]->_loc[2];					minAgentDistSquared = distSquared;					closestAgentType = PREDATOR;				}									for (int k = 0; k < closestNeighbors.size(); k++)					if (distSquared < closestNeighbors[k].second)					{						closestNeighbors[k].first = predators[j];						closestNeighbors[k].second = distSquared;						break;					}			}		}		//Find the number of predators that are close enough to be considered a neighbor	int numNeighbors = 0;	for (int j = 0; j < closestNeighbors.size(); j++)		if (closestNeighbors[j].first)			numNeighbors++;		//Update predator's hunger status	if (minPreyDistSquared < 1.0)		_secsSinceLastFeeding = 0.0;	else _secsSinceLastFeeding += secsTranspired;		//Find the center of gravity and the average velocity of the closest neighbors	GLfloat neighborsCog[3] = { 0 };	GLfloat neighborsVel[3] = { 0 };	int divisor = 0;	for (int j = 0; j < closestNeighbors.size(); j++)		if (closestNeighbors[j].first)		{			vecAdd(neighborsCog, closestNeighbors[j].first->_loc);			vecAdd(neighborsVel, closestNeighbors[j].first->_desiredVel);			divisor++;		}	if (divisor > 0)	{		vecScale(neighborsCog, 1.0 / divisor);		vecScale(neighborsVel, 1.0 / divisor);	}		//Decay frustrations	GLfloat frustrationDecayAmt = 1.0 * secsTranspired;	_cowFrustration -= frustrationDecayAmt;	if (_cowFrustration < 0.0)		_cowFrustration = 0.0;	_neighborsCogFrustration -= frustrationDecayAmt;	if (_neighborsCogFrustration < 0.0)		_neighborsCogFrustration = 0.0;	_neighborsVelFrustration -= frustrationDecayAmt;	if (_neighborsVelFrustration < 0.0)		_neighborsVelFrustration = 0.0;	_avoidanceFrustration -= frustrationDecayAmt;	if (_avoidanceFrustration < 0.0)		_avoidanceFrustration = 0.0;	_predatorHungerFrustration -= frustrationDecayAmt;	if (_predatorHungerFrustration < 0.0)		_predatorHungerFrustration = 0.0;		//Increase frustrations	GLfloat vecToCow[3] = { gSettings.worldCenter[0] - _loc[0], gSettings.worldCenter[1] - _loc[1], gSettings.worldCenter[2] - _loc[2] };	GLfloat vecToCowLen = vecLength(vecToCow);	GLfloat cowFrustration = vecToCowLen * Agent::sWorldCenterStrength * .005;	if (_loc[2] > 0.0 || _loc[2] < -gSettings.worldBounds * .75)		cowFrustration *= 10.0;	//Strong motivation to stay within Z bounds	_cowFrustration += cowFrustration * secsTranspired;	if (_cowFrustration > Agent::skMaxCowFrustration)		_cowFrustration = Agent::skMaxCowFrustration;		GLfloat neighborsCogDist[3] = { 0, 0, 0 };	GLfloat vecToNeighborsCogLen = 0.0;	if (numNeighbors > 0)	{		neighborsCogDist[0] = neighborsCog[0] - _loc[0];		neighborsCogDist[1] = neighborsCog[1] - _loc[1];		neighborsCogDist[2] = neighborsCog[2] - _loc[2];		vecToNeighborsCogLen = vecLength(neighborsCogDist);		GLfloat neighborsCogFrustration = vecToNeighborsCogLen * Agent::sNeighborCogStrength * .01;		_neighborsCogFrustration += neighborsCogFrustration * secsTranspired;		if (_neighborsCogFrustration > Agent::skMaxNeighborsCogFrustration)			_neighborsCogFrustration = Agent::skMaxNeighborsCogFrustration;	}		if (numNeighbors > 0)	{		GLfloat v1b[3] = { _desiredVel[0], _desiredVel[1], _desiredVel[2] };		bool zeroLen = vecNormalize(v1b);		if (!zeroLen)		{			cout << endl << "Aa Zero length vector detected" << endl;			exit(1);		}		GLfloat v2b[3] = { neighborsVel[0], neighborsVel[1], neighborsVel[2] };		zeroLen = vecNormalize(v2b);		if (!zeroLen)		{			cout << endl << "Ab Zero length vector detected" << endl;			exit(1);		}		GLfloat angleToNeighborsVel = acos(vecDot(v1b, v2b));		GLfloat neighborsVelFrustration = fabs(angleToNeighborsVel) * Agent::sNeighborVelocityStrength * .05;		_neighborsVelFrustration += neighborsVelFrustration * secsTranspired;		if (_neighborsVelFrustration > Agent::skMaxNeighborsVelFrustration)			_neighborsVelFrustration = Agent::skMaxNeighborsVelFrustration;	}		if (numNeighbors > 0)	{		if (closestAgentType == UNKNOWN)			quitWithMsg("closestAgentType == UNKNOWN");				if (minAgentDistSquared < Agent::sAvoidanceDistSquared && closestAgentType == PREDATOR)		{			GLfloat minDistSquaredInvNorm = (Agent::sAvoidanceDistSquared - minAgentDistSquared) / Agent::sAvoidanceDistSquared;			GLfloat avoidanceFrustration = minDistSquaredInvNorm * Agent::sAvoidanceStrength * .1;			_avoidanceFrustration += avoidanceFrustration * secsTranspired;			if (_avoidanceFrustration > Agent::skMaxAvoidanceFrustration)				_avoidanceFrustration = Agent::skMaxAvoidanceFrustration;		}	}		GLfloat predatorHungerFrustration = _secsSinceLastFeeding * sPredatorHungerStrength * .01;	_predatorHungerFrustration += predatorHungerFrustration * secsTranspired;	if (_predatorHungerFrustration > skMaxPredatorHungerFrustration)		_predatorHungerFrustration = skMaxPredatorHungerFrustration;		//Determine the dominant frustration (which is not necessarily the strongest frustration)	_dominantFrustrationType = Agent::DRIVE_COW;	//Default to center of world attraction	_dominantFrustration = _cowFrustration;		if (_neighborsCogFrustration > _dominantFrustration && numNeighbors > 0)	{		_dominantFrustrationType = Agent::DRIVE_N_COG;		_dominantFrustration = _neighborsCogFrustration;	}	if (_neighborsVelFrustration > _dominantFrustration && numNeighbors > 0)	{		_dominantFrustrationType = Agent::DRIVE_N_VEL;		_dominantFrustration = _neighborsVelFrustration;	}	if (_avoidanceFrustration > _dominantFrustration && numNeighbors > 0)	{		_dominantFrustrationType = Agent::DRIVE_AVOID;		_dominantFrustration = _avoidanceFrustration;	}	if (_predatorHungerFrustration > _dominantFrustration && minPreyDistSquared < 999999.0)	{		_dominantFrustrationType = Agent::DRIVE_HUNGER;		_dominantFrustration = _predatorHungerFrustration;	}		//Act on the winning frustration (change velocity)	switch (_dominantFrustrationType)	{		case Agent::DRIVE_COW:			{				if (vecToCowLen < 1.0)					break;								GLfloat v1[3] = { _desiredVel[0], _desiredVel[1], _desiredVel[2] };				bool zeroLen = vecNormalize(v1);				GLfloat v2[3] = { vecToCow[0], vecToCow[1], vecToCow[2] };				zeroLen = vecNormalize(v2);								GLfloat axis[3] = { 0 };				vecCross(v1, v2, axis);				GLfloat axisbk[3] = { axis[0], axis[1], axis[2] };				zeroLen = vecNormalize(axis);								if (!zeroLen)				{					cout << "0b Zero length vector detected" << endl;					cout << "    v1     " << v1[0] << " " << v1[1] << " " << v1[2] << endl;					cout << "    v2     " << v2[0] << " " << v2[1] << " " << v2[2] << endl;					cout << "    axisbk " << axisbk[0] << " " << axisbk[1] << " " << axisbk[2] << endl;					cout << "    axis   " << axis[0] << " " << axis[1] << " " << axis[2] << endl;					break;				}								GLfloat angleToCow = acos(vecDot(v1, v2));				if (isnan(angleToCow))				{					cout << "0b Attempting to fix nan acos() for vecDot cos " << vecDot(v1, v2) << endl;					GLfloat v1a[3] = { v1[0], v1[1], v1[2] };					vecSetLength(v1a, .999);					GLfloat v2a[3] = { v2[0], v2[1], v2[2] };					vecSetLength(v2a, .999);										angleToCow = acos(vecDot(v1a, v2a));					if (isnan(angleToCow))						cout << "0b Failed to fix nan acos()" << endl;				}								GLfloat rotStrength = _dominantFrustration;				GLfloat angleRot = angleToCow * rotStrength * secsTranspired;								GLfloat R[16] = { 0.0 };				makeRotMatrix(axis, angleRot, R);								multVecByRotMatrix(v1, R, _desiredVel);								if (isnan(_desiredVel[0]))				{					cout << "0b NAN vel " << endl;					quitWithMsg("NAN");				}			}			break;		case Agent::DRIVE_N_COG:			{				if (vecToNeighborsCogLen < 1.0)					break;								if (numNeighbors == 0)					quitWithMsg("2b Zero neighbors");								GLfloat v1[3] = { _desiredVel[0], _desiredVel[1], _desiredVel[2] };				bool zeroLen = vecNormalize(v1);				GLfloat v2[3] = { neighborsCogDist[0], neighborsCogDist[1], neighborsCogDist[2] };				zeroLen = vecNormalize(v2);								GLfloat axis[3] = { 0 };				vecCross(v1, v2, axis);				zeroLen = vecNormalize(axis);								GLfloat angleToCog = acos(vecDot(v1, v2));				if (isnan(angleToCog))				{					cout << "2b Attempting to fix nan acos() for vecDot cos " << vecDot(v1, v2) << endl;					GLfloat v1a[3] = { v1[0], v1[1], v1[2] };					vecSetLength(v1a, .999);					GLfloat v2a[3] = { v2[0], v2[1], v2[2] };					vecSetLength(v2a, .999);										angleToCog = acos(vecDot(v1a, v2a));					if (isnan(angleToCog))						cout << "2b Failed to fix nan acos()" << endl;				}								GLfloat rotStrength = _dominantFrustration;				GLfloat angleRot = angleToCog * rotStrength * secsTranspired;								GLfloat R[16] = { 0.0 };				makeRotMatrix(axis, angleRot, R);								multVecByRotMatrix(v1, R, _desiredVel);								if (isnan(_desiredVel[0]))				{					cout << "2b NAN vel " << endl;					quitWithMsg("NAN");				}			}			break;		case Agent::DRIVE_N_VEL:			{				if (numNeighbors == 0)					quitWithMsg("3b Zero neighbors");								GLfloat v1[3] = { _desiredVel[0], _desiredVel[1], _desiredVel[2] };				bool zeroLen = vecNormalize(v1);				GLfloat v2[3] = { neighborsVel[0], neighborsVel[1], neighborsVel[2] };				zeroLen = vecNormalize(v2);								if (isnan(v1[0]) || isnan(v1[1]) || isnan(v1[2]))					cout << "nan vectors 1 " << v1[0] << " " << v1[1] << " " << v1[2] << " " << endl;				if (isnan(v2[0]) || isnan(v2[1]) || isnan(v2[2]))					cout << "nan vectors 2 " << v2[0] << " " << v2[1] << " " << v2[2] << " " << endl;								GLfloat axisb[3] = { 0 };				vecCross(v1, v2, axisb);				zeroLen = vecNormalize(axisb);								GLfloat angleToNeighborsVel = acos(vecDot(v1, v2));				if (isnan(angleToNeighborsVel))				{					cout << "3b Attempting to fix nan acos() for vecDot cos " << vecDot(v1, v2) << endl;					GLfloat v1a[3] = { v1[0], v1[1], v1[2] };					vecSetLength(v1a, .999);					GLfloat v2a[3] = { v2[0], v2[1], v2[2] };					vecSetLength(v2a, .999);										angleToNeighborsVel = acos(vecDot(v1a, v2a));					if (isnan(angleToNeighborsVel))						cout << "3b Failed to fix nan acos()" << endl;				}								GLfloat rotStrength = _dominantFrustration;				GLfloat angleRotb = angleToNeighborsVel * rotStrength * secsTranspired;								GLfloat Rb[16] = { 0.0 };				makeRotMatrix(axisb, angleRotb, Rb);								multVecByRotMatrix(v1, Rb, _desiredVel);								if (isnan(_desiredVel[0]))				{					cout << "3b NAN vel " << endl;					quitWithMsg("NAN");				}			}			break;		case Agent::DRIVE_AVOID:			{				if (numNeighbors == 0)					quitWithMsg("4 Zero neighbors");								GLfloat v1[3] = { _desiredVel[0], _desiredVel[1], _desiredVel[2] };				bool zeroLen = vecNormalize(v1);				GLfloat v2[3] = { _loc[0] - minAgentDistLoc[0], _loc[1] - minAgentDistLoc[1], _loc[2] - minAgentDistLoc[2] };				zeroLen = vecNormalize(v2);								GLfloat axis[3] = { 0 };				vecCross(v1, v2, axis);				zeroLen = vecNormalize(axis);								GLfloat angleToNeighbor = acos(vecDot(v1, v2));				if (isnan(angleToNeighbor))				{					cout << "4b Attempting to fix nan acos() for vecDot cos " << vecDot(v1, v2) << endl;					GLfloat v1a[3] = { v1[0], v1[1], v1[2] };					vecSetLength(v1a, .999);					GLfloat v2a[3] = { v2[0], v2[1], v2[2] };					vecSetLength(v2a, .999);										angleToNeighbor = acos(vecDot(v1a, v2a));					if (isnan(angleToNeighbor))						cout << "4b Failed to fix nan acos()" << endl;				}								GLfloat rotStrength = _dominantFrustration;				GLfloat angleRot = angleToNeighbor * rotStrength * secsTranspired;								GLfloat R[16] = { 0.0 };				makeRotMatrix(axis, angleRot, R);								multVecByRotMatrix(v1, R, _desiredVel);								if (isnan(_desiredVel[0]))				{					cout << "4b NAN vel" << endl;					quitWithMsg("NAN");				}			}			break;		case Agent::DRIVE_HUNGER:			{				if (minPreyDistSquared > 999998.0)					quitWithMsg("5b No prey to chase");								GLfloat v1[3] = { _desiredVel[0], _desiredVel[1], _desiredVel[2] };				bool zeroLen = vecNormalize(v1);				GLfloat v2[3] = { minPreyDistLoc[0] - _loc[0], minPreyDistLoc[1] - _loc[1], minPreyDistLoc[2] - _loc[2] };				zeroLen = vecNormalize(v2);								GLfloat axis[3] = { 0 };				vecCross(v1, v2, axis);				zeroLen = vecNormalize(axis);								GLfloat angleToPrey = acos(vecDot(v1, v2));				if (isnan(angleToPrey))				{					cout << "5b Attempting to fix nan acos() for vecDot cos " << vecDot(v1, v2) << endl;					GLfloat v1a[3] = { v1[0], v1[1], v1[2] };					vecSetLength(v1a, .999);					GLfloat v2a[3] = { v2[0], v2[1], v2[2] };					vecSetLength(v2a, .999);										angleToPrey = acos(vecDot(v1a, v2a));					if (isnan(angleToPrey))						cout << "5b Failed to fix nan acos()" << endl;				}								GLfloat rotStrength = _dominantFrustration;				GLfloat angleRot = angleToPrey * rotStrength * secsTranspired;								GLfloat R[16] = { 0.0 };				makeRotMatrix(axis, angleRot, R);								multVecByRotMatrix(v1, R, _desiredVel);								if (isnan(_desiredVel[0]))				{					cout << "5b NAN vel" << endl;					quitWithMsg("NAN");				}			}			break;		case Agent::DRIVE_COG:			quitWithMsg("Predator tried for species cog");			break;		default:			quitWithMsg("Unrecognized frustration type");	}		//Maintain desired _speed	GLfloat presentSpeed = _speed * gSettings.speedScalar * max(_dominantFrustration * 10.0f, 1.0f);		if (_dominantFrustrationType == DRIVE_N_VEL)		presentSpeed *= .5;	//This scalar helps the simulation behave more nicely when acting on this frustration.		vecSetLength(_desiredVel, presentSpeed);		//Drag by the drift velocity and combine with the target velocity	for (int j = 0; j < 3; j++)		_actualVel[j] = (_actualVel[j] * gSettings.driftDrag + _desiredVel[j]) / (gSettings.driftDrag + 1.0);		//Update the location based on the velocity	_loc[0] += _actualVel[0] * secsTranspired;	_loc[1] += _actualVel[1] * secsTranspired;	_loc[2] += _actualVel[2] * secsTranspired;		if (isnan(_desiredVel[0]))	{		cout << "NAN vel " << idx << endl;		quitWithMsg("NAN");	}		//Update the body animation	if (gSettings.bodyAnimationEnabled)	{		GLfloat tailSpeed = presentSpeed * secsTranspired * 3.0;		_tailPos += _tailMovingForward ? tailSpeed : -tailSpeed;		if (_tailPos > 1.0)		{			_tailPos = 1.0;			_tailMovingForward = false;		}		else if (_tailPos < -1.0)		{			_tailPos = -1.0;			_tailMovingForward = true;		}	}}