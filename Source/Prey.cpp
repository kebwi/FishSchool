#include "Prey.h"#include "Predator.h"#include "Random.h"#include "MathStuff.h"#include "smallStructs.h"#include <iostream>#include <vector>#include <algorithm>	//for min/max#include <utility>	//for pair<>using namespace std;//======================================================================//Constsconst GLfloat Prey::skMaxPredatorEvasionDist = 10.0;const GLfloat Prey::skMaxPredatorEvasionDistSquared = skMaxPredatorEvasionDist * skMaxPredatorEvasionDist;const int Prey::skMaxNeighborsPrey = 10;const GLfloat Prey::skMaxPreyEvasionFrustration = 1.5;const GLfloat Prey::skMaxCogFrustration = .9;const GLfloat Prey::skMaxNearestNeighborFrustration = .85;const float Prey::skMaterialColor[]	 = {0.0f, 0.5f, 0.2f, 1.0f};//======================================================================//Extern Global variablesextern Settings gSettings;//======================================================================//Global variablesGLfloat Prey::sNearestNeighborDistanceSquared = 2.0 * 2.0;GLfloat Prey::sSchoolCOGStrength = 20.0;GLfloat Prey::sNearestNeighborStrength = 10.0;GLfloat Prey::sPreyEvasionStrength = 100.0;//======================================================================//Function prototypesvoid checkError(GLint status, const char *msg);void quit();void quitWithMsg(const char* msg);//======================================================================Prey::Prey() : Agent(){	_cogFrustration = 0.0;	_nearestNeighborDistanceFrustration = 0.0;		_color[0] = skMaterialColor[0];	_color[1] = skMaterialColor[1] + RandZeroFloat(.5);	Constrain(0.0, _color[1], 1.0);	_color[2] = skMaterialColor[2] + RandZeroFloat(.5);	Constrain(0.0, _color[2], 1.0);		_speed = .75;		vecSetLength(_desiredVel, _speed * gSettings.speedScalar);}Prey::~Prey(){}void Prey::draw(){	//Note that the following test will not work properly if the camera is rotated.	//However, doing a Z-test and then setting alpha to 0 when behind the camera in the vertex shader	//runs very slow when fog is turned on, which occurs in the fragment shader.	if (_loc[2] > 0.0)		return;	//Agent is behind the camera    	float materialColor[4] = { 0, 0, 0, 1 };	for (int j = 0; j < 4; j++)		materialColor[j] = skMaterialColor[j];		if (gSettings.showFrustration)	{		switch (_dominantFrustrationType)		{			case Agent::DRIVE_COW:				materialColor[0] = 1.0;				materialColor[1] = 0.0;				materialColor[2] = 0.0;				break;			case Agent::DRIVE_N_COG:				materialColor[0] = 0.0;				materialColor[1] = 1.0;				materialColor[2] = 0.0;				break;			case Agent::DRIVE_N_VEL:				materialColor[0] = 0.0;				materialColor[1] = 0.0;				materialColor[2] = 1.0;				break;			case Agent::DRIVE_AVOID:				materialColor[0] = 1.0;				materialColor[1] = 1.0;				materialColor[2] = 0.0;				break;			case Agent::DRIVE_COG:				materialColor[0] = 1.0;				materialColor[1] = 0.0;				materialColor[2] = 1.0;				break;			case Agent::DRIVE_NN_DIST:				materialColor[0] = 0.0;				materialColor[1] = 1.0;				materialColor[2] = 1.0;				break;			case Agent::DRIVE_EVADE:				materialColor[0] = 0.0;				materialColor[1] = 1.0;				materialColor[2] = 0.5;				break;			case Agent::DRIVE_HUNGER:				quitWithMsg("Dominant prey drive hunger");				break;		}		glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, materialColor);	}	else	//Don't show frustration type	{		if (_dominantFrustrationType != Agent::DRIVE_EVADE)		{			for (int j = 0; j < 4; j++)				materialColor[j] = _color[j];			materialColor[0] = _preyEvasionFrustration / skMaxPreyEvasionFrustration;			glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, materialColor);		}		else		{			for (int j = 0; j < 4; j++)				materialColor[j] = _color[j];			materialColor[0] = _preyEvasionFrustration / skMaxPreyEvasionFrustration;			materialColor[1] *= .75 + (.25 - (_dominantFrustration / (skMaxPreyEvasionFrustration * 4.0)));			materialColor[2] *= .75 + (.25 - (_dominantFrustration / (skMaxPreyEvasionFrustration * 4.0)));			glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, materialColor);		}	}	if (!gSettings.useShader)	{		glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, skMaterialSpecular);		glMaterialf(GL_FRONT, GL_SHININESS, skMaterialShininess);	}		glPushMatrix();				//Rotate camera		glRotatef(gSettings.cameraYaw, 0.0, 1.0, 0.0);		glRotatef(gSettings.cameraPitch, 1.0, 0.0, 0.0);		glRotatef(gSettings.cameraPitch, 0.0, 0.0, 1.0);				//Move to location		glTranslatef(_loc[0], _loc[1], _loc[2]);				//Rotate the agent to point toward the direction of travel		GLfloat v1[3] = { 0.0, 0.0, 1.0 };		bool zeroLen = vecNormalize(v1);		GLfloat v2[3] = { _actualVel[0], _actualVel[1], _actualVel[2] };		zeroLen = vecNormalize(v2);				GLfloat axis[3] = { 0 };		vecCross(v1, v2, axis);		zeroLen = vecNormalize(axis);				GLfloat angleToVel = acos(vecDot(v1, v2));		if (isnan(angleToVel))		{			GLfloat v1a[3] = { v1[0], v1[1], v1[2] };			vecSetLength(v1a, .999);			GLfloat v2a[3] = { v2[0], v2[1], v2[2] };			vecSetLength(v2a, .999);						angleToVel = acos(vecDot(v1a, v2a));			//cout << "Attempted to fix nan acos() in draw() A" << endl;		}				glRotatef(RadToDeg(angleToVel), axis[0], axis[1], axis[2]);				//Find the distance from the origin (and thus from the camera)		float distInv = max(gSettings.worldBounds - vecLength(_loc), 0.0f);				int sphereSections = 12, coneSections = 12, torusSections = 12;		//int sphereSections = 24, coneSections = 24, torusSections = 24;	//Super hi resolution				if (gSettings.distanceVertexComplexityScalingEnabled)		{			sphereSections = (int)(distInv * .45 + 3.01);			Truncate(3, sphereSections, 12);						coneSections = (int)(distInv * .3 + 6.01);			Truncate(6, coneSections, 12);						torusSections = (int)(distInv * .3 + 6.01);			Truncate(6, torusSections, 12);		}				//Body		glPushMatrix();			glScalef(.25, .75, 1.0);			glutSolidSphere(.75, sphereSections, sphereSections);		glPopMatrix();				//Tail		glPushMatrix();			glTranslatef(0.0, 0.0, -.625);			if (gSettings.bodyAnimationEnabled)				glRotatef(_tailPos * 25.0, 0.0, 1.0, 0.0);			glTranslatef(0.0, 0.0, -.5);			glScalef(.1, 1.0, 1.0);			//glutWireCone(.5, .75, coneSections, 1);			glutSolidCone(.5, .75, coneSections, 1);		glPopMatrix();				//Fin		glPushMatrix();			glScalef(.75, 1.0, 1.0);			if (gSettings.bodyAnimationEnabled)				glRotatef(_tailPos * 15.0, 0.0, 0.0, 1.0);			glRotatef(120.0, 0.0, 0.0, 1.0);			glTranslatef(0.0, .3, 0.0);			glRotatef(90.0, 0.0, 1.0, 0.0);			//glutWireTorus(.07, .3, 4, torusSections);			glutSolidTorus(.07, .3, 4, torusSections);		glPopMatrix();				//Fin		glPushMatrix();			glScalef(.75, 1.0, 1.0);			if (gSettings.bodyAnimationEnabled)				glRotatef(-_tailPos * 15.0, 0.0, 0.0, 1.0);			glRotatef(-120.0, 0.0, 0.0, 1.0);			glTranslatef(0.0, .3, 0.0);			glRotatef(90.0, 0.0, 1.0, 0.0);			//glutWireTorus(.07, .3, 4, torusSections);			glutSolidTorus(.07, .3, 4, torusSections);		glPopMatrix();			glPopMatrix();}void Prey::update(int idx, vector<Prey*> prey, vector<Predator*> predators, GLfloat preyCog[3], double secsTranspired){	_stateColor[0] = _stateColor[1] = _stateColor[2] = 0.0;		//Find the single closest agent of either species (for avoidance),	//the single closest agent of the matching species (for flocking),	//the single closest predator (for evasion),	//and the closest group of neighbors of the matching species (for flocking)	GLfloat minAgentDist_loc[3] = { 0, 0, 0 };	GLfloat minAgentDistSquared = 999999.0;	GLfloat minPreyDist_loc[3] = { 0, 0, 0 };	GLfloat minPreyDistSquared = 999999.0;	GLfloat minPredatorDist_loc[3] = { 0, 0, 0 };	GLfloat minPredatorDistSquared = 999999.0;		//Init a vector that will be filled with the closest prey	vector<pair<Prey*, GLfloat> > closestNeighbors;	for (int j = 0; j < skMaxNeighborsPrey; j++)		closestNeighbors.push_back(pair<Prey*, GLfloat>(NULL, 999999.0));		//Find the closest prey and insert them into the vector	for (int j = 0; j < gSettings.numPrey; j++)		if (j != idx)		{			GLfloat v[3] = { prey[j]->_loc[0] - _loc[0], prey[j]->_loc[1] - _loc[1], prey[j]->_loc[2] - _loc[2] };			GLfloat distSquared = vecLengthSquared(v);			if (distSquared < Agent::skMaxOtherAgentDetectDistSquared)			{				if (distSquared < minAgentDistSquared)				{					minAgentDist_loc[0] = prey[j]->_loc[0];					minAgentDist_loc[1] = prey[j]->_loc[1];					minAgentDist_loc[2] = prey[j]->_loc[2];					minAgentDistSquared = distSquared;				}								if (distSquared < minPreyDistSquared)				{					minPreyDist_loc[0] = prey[j]->_loc[0];					minPreyDist_loc[1] = prey[j]->_loc[1];					minPreyDist_loc[2] = prey[j]->_loc[2];					minPreyDistSquared = distSquared;				}									for (int k = 0; k < closestNeighbors.size(); k++)					if (distSquared < closestNeighbors[k].second)					{						closestNeighbors[k].first = prey[j];						closestNeighbors[k].second = distSquared;						break;					}			}		}		//Find the closest predator	for (int j = 0; j < gSettings.numPredators; j++)	{		GLfloat v[3] = { predators[j]->_loc[0] - _loc[0], predators[j]->_loc[1] - _loc[1], predators[j]->_loc[2] - _loc[2] };		GLfloat distSquared = vecLengthSquared(v);		if (distSquared < Agent::skMaxOtherAgentDetectDistSquared)		{			if (distSquared < minAgentDistSquared)			{				minAgentDist_loc[0] = predators[j]->_loc[0];				minAgentDist_loc[1] = predators[j]->_loc[1];				minAgentDist_loc[2] = predators[j]->_loc[2];				minAgentDistSquared = distSquared;			}						if (distSquared < skMaxPredatorEvasionDistSquared && distSquared < minPredatorDistSquared)			{				minPredatorDist_loc[0] = predators[j]->_loc[0];				minPredatorDist_loc[1] = predators[j]->_loc[1];				minPredatorDist_loc[2] = predators[j]->_loc[2];				minPredatorDistSquared = distSquared;			}		}	}		//Find the number of prey that are close enough to be considered a neighbor	int numNeighbors = 0;	for (int j = 0; j < closestNeighbors.size(); j++)		if (closestNeighbors[j].first)			numNeighbors++;		//Find the center of gravity and the average velocity of the closest neighbors	GLfloat neighborsCog[3] = { 0 };	GLfloat neighborsVel[3] = { 0 };	int divisor = 0;	for (int j = 0; j < closestNeighbors.size(); j++)		if (closestNeighbors[j].first)		{			vecAdd(neighborsCog, closestNeighbors[j].first->_loc);			vecAdd(neighborsVel, closestNeighbors[j].first->_desiredVel);			divisor++;		}	if (divisor > 0)	{		vecScale(neighborsCog, 1.0 / divisor);		vecScale(neighborsVel, 1.0 / divisor);	}		//Decay frustrations	GLfloat frustrationDecayAmt = 1.0 * secsTranspired;	_cowFrustration -= frustrationDecayAmt;	if (_cowFrustration < 0.0)		_cowFrustration = 0.0;	_cogFrustration -= frustrationDecayAmt;	if (_cogFrustration < 0.0)		_cogFrustration = 0.0;	_neighborsCogFrustration -= frustrationDecayAmt;	if (_neighborsCogFrustration < 0.0)		_neighborsCogFrustration = 0.0;	_nearestNeighborDistanceFrustration -= frustrationDecayAmt;	if (_nearestNeighborDistanceFrustration < 0.0)		_nearestNeighborDistanceFrustration = 0.0;	_neighborsVelFrustration -= frustrationDecayAmt;	if (_neighborsVelFrustration < 0.0)		_neighborsVelFrustration = 0.0;	_avoidanceFrustration -= frustrationDecayAmt;	if (_avoidanceFrustration < 0.0)		_avoidanceFrustration = 0.0;	_preyEvasionFrustration -= frustrationDecayAmt;	if (_preyEvasionFrustration < 0.0)		_preyEvasionFrustration = 0.0;		//Increase frustrations	GLfloat vecToCow[3] = { gSettings.worldCenter[0] - _loc[0], gSettings.worldCenter[1] - _loc[1], gSettings.worldCenter[2] - _loc[2] };	GLfloat vecToCowLen = vecLength(vecToCow);	GLfloat cowFrustration = vecToCowLen * Agent::sWorldCenterStrength * .005;	if (_loc[2] > 0.0 || _loc[2] < -gSettings.worldBounds * .75)		cowFrustration *= 10.0;	//Strong motivation to stay within Z bounds	_cowFrustration += cowFrustration * secsTranspired;	if (_cowFrustration > Agent::skMaxCowFrustration)		_cowFrustration = Agent::skMaxCowFrustration;		GLfloat vecToCog[3] = { preyCog[0] - _loc[0], preyCog[1] - _loc[1], preyCog[2] - _loc[2] };	GLfloat vecToCogLen = vecLength(vecToCog);		GLfloat cogFrustration = vecToCogLen * sSchoolCOGStrength * .005;	_cogFrustration += cogFrustration * secsTranspired;	if (_cogFrustration > skMaxCogFrustration)		_cogFrustration = skMaxCogFrustration;		GLfloat neighborsCogDist[3] = { 0, 0, 0 };	GLfloat vecToNeighborsCogLen = 0.0;	if (numNeighbors > 0)	{		neighborsCogDist[0] = neighborsCog[0] - _loc[0];		neighborsCogDist[1] = neighborsCog[1] - _loc[1];		neighborsCogDist[2] = neighborsCog[2] - _loc[2];		vecToNeighborsCogLen = vecLength(neighborsCogDist);		GLfloat neighborsCogFrustration = vecToNeighborsCogLen * Agent::sNeighborCogStrength * .01;		_neighborsCogFrustration += neighborsCogFrustration * secsTranspired;		if (_neighborsCogFrustration > Agent::skMaxNeighborsCogFrustration)			_neighborsCogFrustration = Agent::skMaxNeighborsCogFrustration;	}		if (numNeighbors > 0)	{		if (minPreyDistSquared > sNearestNeighborDistanceSquared)		{			GLfloat nearestNeighborDistanceFrustration = minPreyDistSquared * sNearestNeighborStrength * .01;			_nearestNeighborDistanceFrustration += nearestNeighborDistanceFrustration * secsTranspired;			if (_nearestNeighborDistanceFrustration > skMaxNearestNeighborFrustration)				_nearestNeighborDistanceFrustration = skMaxNearestNeighborFrustration;		}	}		if (numNeighbors > 0)	{		GLfloat v1b[3] = { _desiredVel[0], _desiredVel[1], _desiredVel[2] };		bool zeroLen = vecNormalize(v1b);		if (!zeroLen)		{			cout << endl << "Aa Zero length vector detected" << endl;			exit(1);		}		GLfloat v2b[3] = { neighborsVel[0], neighborsVel[1], neighborsVel[2] };		zeroLen = vecNormalize(v2b);		if (!zeroLen)		{			cout << endl << "Ab Zero length vector detected" << endl;			exit(1);		}		GLfloat angleToNeighborsVel = acos(vecDot(v1b, v2b));		GLfloat neighborsVelFrustration = fabs(angleToNeighborsVel) * Agent::sNeighborVelocityStrength * .05;		_neighborsVelFrustration += neighborsVelFrustration * secsTranspired;		if (_neighborsVelFrustration > Agent::skMaxNeighborsVelFrustration)			_neighborsVelFrustration = Agent::skMaxNeighborsVelFrustration;	}		if (numNeighbors > 0)	{		if (minAgentDistSquared < Agent::sAvoidanceDistSquared)		{			GLfloat minDistSquaredInvNorm = (Agent::sAvoidanceDistSquared - minAgentDistSquared) / Agent::sAvoidanceDistSquared;			GLfloat avoidanceFrustration = minDistSquaredInvNorm * Agent::sAvoidanceStrength * .1;			_avoidanceFrustration += avoidanceFrustration * secsTranspired;			if (_avoidanceFrustration > Agent::skMaxAvoidanceFrustration)				_avoidanceFrustration = Agent::skMaxAvoidanceFrustration;		}	}		if (minPredatorDistSquared < 999998.0)	{		GLfloat minPredatorDist = sqrt(minPredatorDistSquared);		GLfloat predatorDistInvNorm = (skMaxPredatorEvasionDist - minPredatorDist) / skMaxPredatorEvasionDist;				GLfloat preyEvasionFrustration = predatorDistInvNorm * sPreyEvasionStrength * 10.0;		_preyEvasionFrustration += preyEvasionFrustration * secsTranspired;		if (_preyEvasionFrustration > skMaxPreyEvasionFrustration)			_preyEvasionFrustration = skMaxPreyEvasionFrustration;	}		//Determine the dominant frustration (which is not necessarily the strongest frustration)	_dominantFrustrationType = Agent::DRIVE_COW;	//Default to center of world attraction	_dominantFrustration = _cowFrustration;		if (_cogFrustration > _dominantFrustration)	{		_dominantFrustrationType = Agent::DRIVE_COG;		_dominantFrustration = _cogFrustration;	}	if (_neighborsCogFrustration > _dominantFrustration && numNeighbors > 0)	{		_dominantFrustrationType = Agent::DRIVE_N_COG;		_dominantFrustration = _neighborsCogFrustration;	}	if (_nearestNeighborDistanceFrustration > _dominantFrustration && numNeighbors > 0)	{		_dominantFrustrationType = Agent::DRIVE_NN_DIST;		_dominantFrustration = _nearestNeighborDistanceFrustration;	}	if (_neighborsVelFrustration > _dominantFrustration && numNeighbors > 0)	{		_dominantFrustrationType = Agent::DRIVE_N_VEL;		_dominantFrustration = _neighborsVelFrustration;	}	if (_avoidanceFrustration > _dominantFrustration && numNeighbors > 0)	{		_dominantFrustrationType = Agent::DRIVE_AVOID;		_dominantFrustration = _avoidanceFrustration;	}	if (_preyEvasionFrustration > _dominantFrustration && minPredatorDistSquared < 999998.0)	{		_dominantFrustrationType = Agent::DRIVE_EVADE;		_dominantFrustration = _preyEvasionFrustration;	}		//Act on the dominant frustration (change velocity)	switch (_dominantFrustrationType)	{		case Agent::DRIVE_COW:			{				if (vecToCowLen < 1.0)					break;								int zl = 0;								GLfloat v1[3] = { _desiredVel[0], _desiredVel[1], _desiredVel[2] };				bool zeroLen = vecNormalize(v1);				if (!zeroLen)					zl++;				GLfloat v2[3] = { vecToCow[0], vecToCow[1], vecToCow[2] };				zeroLen = vecNormalize(v2);				if (!zeroLen)					zl++;								GLfloat axis[3] = { 0 };				vecCross(v1, v2, axis);				GLfloat axisbk[3] = { axis[0], axis[1], axis[2] };				zeroLen = vecNormalize(axis);								if (!zeroLen || zl != 0)				{					cout << endl << "0a Zero length vector detected" << endl;					cout << "    loc    " << _loc[0] << " " << _loc[1] << " " << _loc[2] << endl;					cout << "    v2cowL " << vecToCowLen << endl;					cout << "    v1     " << v1[0] << " " << v1[1] << " " << v1[2] << endl;					cout << "    v2     " << v2[0] << " " << v2[1] << " " << v2[2] << endl;					cout << "    axisbk " << axisbk[0] << " " << axisbk[1] << " " << axisbk[2] << endl;					cout << "    vd     " << vecDot(v1, v2) << endl;					cout << "    axis   " << axis[0] << " " << axis[1] << " " << axis[2] << endl;					exit(1);					break;				}								GLfloat angleToCow = acos(vecDot(v1, v2));				if (isnan(angleToCow))				{					cout << "0a Attempting to fix nan acos() for vecDot cos " << vecDot(v1, v2) << endl;					GLfloat v1a[3] = { v1[0], v1[1], v1[2] };					vecSetLength(v1a, .999);					GLfloat v2a[3] = { v2[0], v2[1], v2[2] };					vecSetLength(v2a, .999);										angleToCow = acos(vecDot(v1a, v2a));					if (isnan(angleToCow))						cout << "0a Failed to fix nan acos()" << endl;				}								GLfloat rotStrength = _dominantFrustration;				GLfloat angleRot = angleToCow * rotStrength * secsTranspired;								GLfloat R[16] = { 0.0 };				makeRotMatrix(axis, angleRot, R);								multVecByRotMatrix(v1, R, _desiredVel);								if (isnan(_desiredVel[0]))				{					cout << "0a NAN vel " << endl;					quitWithMsg("NAN");				}			}			break;		case Agent::DRIVE_COG:			{				if (vecToCogLen < 1.0)					break;								GLfloat v1[3] = { _desiredVel[0], _desiredVel[1], _desiredVel[2] };				bool zeroLen = vecNormalize(v1);				GLfloat v2[3] = { vecToCog[0], vecToCog[1], vecToCog[2] };				zeroLen = vecNormalize(v2);								GLfloat axis[3] = { 0 };				vecCross(v1, v2, axis);				zeroLen = vecNormalize(axis);								GLfloat angleToCog = acos(vecDot(v1, v2));				if (isnan(angleToCog))				{					cout << "1a Attempting to fix nan acos() for vecDot cos " << vecDot(v1, v2) << endl;					GLfloat v1a[3] = { v1[0], v1[1], v1[2] };					vecSetLength(v1a, .999);					GLfloat v2a[3] = { v2[0], v2[1], v2[2] };					vecSetLength(v2a, .999);										angleToCog = acos(vecDot(v1a, v2a));					if (isnan(angleToCog))						cout << "1a Failed to fix nan acos()" << endl;				}								if (isnan(angleToCog))					cout << "NAN angleToCog " << v1[0] << " " << v1[1] << " " << v1[2] << " " <<												v2[0] << " " << v2[1] << " " << v2[2] << " " <<												vecLength(v1) << " " << vecLength(v2) << " " << vecDot(v1, v2) << endl;								GLfloat rotStrength = _dominantFrustration;				GLfloat angleRot = angleToCog * rotStrength * secsTranspired;								GLfloat R[16] = { 0.0 };				makeRotMatrix(axis, angleRot, R);								multVecByRotMatrix(v1, R, _desiredVel);								if (isnan(_desiredVel[0]))				{					cout << "1a NAN vel " << endl;					quitWithMsg("NAN");				}			}			break;		case Agent::DRIVE_N_COG:			{				if (numNeighbors == 0)					quitWithMsg("Zero neighbors 2");								if (vecToNeighborsCogLen < 1.0)					break;								GLfloat v1[3] = { _desiredVel[0], _desiredVel[1], _desiredVel[2] };				bool zeroLen = vecNormalize(v1);				GLfloat v2[3] = { neighborsCogDist[0], neighborsCogDist[1], neighborsCogDist[2] };				zeroLen = vecNormalize(v2);								GLfloat axis[3] = { 0 };				vecCross(v1, v2, axis);				zeroLen = vecNormalize(axis);								GLfloat angleToCog = acos(vecDot(v1, v2));				if (isnan(angleToCog))				{					cout << "2 Attempting to fix nan acos() for vecDot cos " << vecDot(v1, v2) << endl;					GLfloat v1a[3] = { v1[0], v1[1], v1[2] };					vecSetLength(v1a, .999);					GLfloat v2a[3] = { v2[0], v2[1], v2[2] };					vecSetLength(v2a, .999);										angleToCog = acos(vecDot(v1a, v2a));					if (isnan(angleToCog))						cout << "2 Failed to fix nan acos()" << endl;				}								GLfloat rotStrength = _dominantFrustration;				GLfloat angleRot = angleToCog * rotStrength * secsTranspired;								GLfloat R[16] = { 0.0 };				makeRotMatrix(axis, angleRot, R);								multVecByRotMatrix(v1, R, _desiredVel);								if (isnan(_desiredVel[0]))				{					cout << "2 NAN vel " << endl;					quitWithMsg("NAN");				}			}			break;		case Agent::DRIVE_N_VEL:			{				if (numNeighbors == 0)					quitWithMsg("3a Zero neighbors");								GLfloat v1[3] = { _desiredVel[0], _desiredVel[1], _desiredVel[2] };				bool zeroLen = vecNormalize(v1);				GLfloat v2[3] = { neighborsVel[0], neighborsVel[1], neighborsVel[2] };				zeroLen = vecNormalize(v2);								GLfloat axisb[3] = { 0 };				vecCross(v1, v2, axisb);				zeroLen = vecNormalize(axisb);								GLfloat angleToNeighborsVel = acos(vecDot(v1, v2));				if (isnan(angleToNeighborsVel))				{					cout << "3a Attempting to fix nan acos() for vecDot cos " << vecDot(v1, v2) << endl;					GLfloat v1a[3] = { v1[0], v1[1], v1[2] };					vecSetLength(v1a, .999);					GLfloat v2a[3] = { v2[0], v2[1], v2[2] };					vecSetLength(v2a, .999);										angleToNeighborsVel = acos(vecDot(v1a, v2a));					if (isnan(angleToNeighborsVel))						cout << "3a Failed to fix nan acos()" << endl;				}								GLfloat rotStrength = _dominantFrustration;				GLfloat angleRotb = angleToNeighborsVel * rotStrength * secsTranspired;								GLfloat Rb[16] = { 0.0 };				makeRotMatrix(axisb, angleRotb, Rb);								multVecByRotMatrix(v1, Rb, _desiredVel);								if (isnan(_desiredVel[0]))				{					cout << "3a NAN vel " << endl;					quitWithMsg("NAN");				}			}			break;		case Agent::DRIVE_AVOID:			{				if (numNeighbors == 0)					quitWithMsg("4a Zero neighbors");								GLfloat v1[3] = { _desiredVel[0], _desiredVel[1], _desiredVel[2] };				bool zeroLen = vecNormalize(v1);				GLfloat v2[3] = { _loc[0] - minAgentDist_loc[0], _loc[1] - minAgentDist_loc[1], _loc[2] - minAgentDist_loc[2] };				zeroLen = vecNormalize(v2);								GLfloat axis[3] = { 0 };				vecCross(v1, v2, axis);				zeroLen = vecNormalize(axis);								GLfloat angleToNeighbor = acos(vecDot(v1, v2));				if (isnan(angleToNeighbor))				{					cout << "4a Attempting to fix nan acos() for vecDot cos " << vecDot(v1, v2) << endl;					GLfloat v1a[3] = { v1[0], v1[1], v1[2] };					vecSetLength(v1a, .999);					GLfloat v2a[3] = { v2[0], v2[1], v2[2] };					vecSetLength(v2a, .999);										angleToNeighbor = acos(vecDot(v1a, v2a));					if (isnan(angleToNeighbor))						cout << "4a Failed to fix nan acos()" << endl;				}								GLfloat rotStrength = _dominantFrustration;				GLfloat angleRot = angleToNeighbor * rotStrength * secsTranspired;								GLfloat R[16] = { 0.0 };				makeRotMatrix(axis, angleRot, R);								multVecByRotMatrix(v1, R, _desiredVel);								if (isnan(_desiredVel[0]))				{					cout << "4a NAN vel " << endl;					quitWithMsg("NAN");				}			}			break;		case Agent::DRIVE_EVADE:			{				if (minPredatorDistSquared > 999998.0)					quitWithMsg("6a No predator to evade");								GLfloat v1[3] = { _desiredVel[0], _desiredVel[1], _desiredVel[2] };				bool zeroLen = vecNormalize(v1);				GLfloat v2[3] = { _loc[0] - minPredatorDist_loc[0], _loc[1] - minPredatorDist_loc[1], _loc[2] - minPredatorDist_loc[2] };				zeroLen = vecNormalize(v2);								GLfloat axis[3] = { 0 };				vecCross(v1, v2, axis);				zeroLen = vecNormalize(axis);								GLfloat angleToNeighbor = acos(vecDot(v1, v2));				if (isnan(angleToNeighbor))				{					cout << "6a Attempting to fix nan acos() for vecDot cos " << vecDot(v1, v2) << endl;					GLfloat v1a[3] = { v1[0], v1[1], v1[2] };					vecSetLength(v1a, .999);					GLfloat v2a[3] = { v2[0], v2[1], v2[2] };					vecSetLength(v2a, .999);										angleToNeighbor = acos(vecDot(v1a, v2a));					if (isnan(angleToNeighbor))						cout << "6a Failed to fix nan acos()" << endl;				}								GLfloat rotStrength = _dominantFrustration;				GLfloat angleRot = angleToNeighbor * rotStrength * secsTranspired;								GLfloat R[16] = { 0.0 };				makeRotMatrix(axis, angleRot, R);								multVecByRotMatrix(v1, R, _desiredVel);								if (isnan(_desiredVel[0]))				{					cout << "6a NAN vel " << endl;					quitWithMsg("NAN");				}			}			break;		case Agent::DRIVE_NN_DIST:			{				GLfloat v1[3] = { _desiredVel[0], _desiredVel[1], _desiredVel[2] };				bool zeroLen = vecNormalize(v1);				GLfloat v2[3] = { minPreyDist_loc[0] - _loc[0], minPreyDist_loc[1] - _loc[1], minPreyDist_loc[2] - _loc[2] };				zeroLen = vecNormalize(v2);								GLfloat axis[3] = { 0 };				vecCross(v1, v2, axis);				zeroLen = vecNormalize(axis);								GLfloat angleToNearestNeighbor = acos(vecDot(v1, v2));				if (isnan(angleToNearestNeighbor))				{					cout << "7a Attempting to fix nan acos() for vecDot cos " << vecDot(v1, v2) << endl;					GLfloat v1a[3] = { v1[0], v1[1], v1[2] };					vecSetLength(v1a, .999);					GLfloat v2a[3] = { v2[0], v2[1], v2[2] };					vecSetLength(v2a, .999);										angleToNearestNeighbor = acos(vecDot(v1a, v2a));					if (isnan(angleToNearestNeighbor))						cout << "7a Failed to fix nan acos()" << endl;				}								if (isnan(angleToNearestNeighbor))					cout << "NAN angleToNearestNeighbor " << v1[0] << " " << v1[1] << " " << v1[2] << " " <<												v2[0] << " " << v2[1] << " " << v2[2] << " " <<												vecLength(v1) << " " << vecLength(v2) << " " << vecDot(v1, v2) << endl;								GLfloat rotStrength = _dominantFrustration;				GLfloat angleRot = angleToNearestNeighbor * rotStrength * secsTranspired;								GLfloat R[16] = { 0.0 };				makeRotMatrix(axis, angleRot, R);								multVecByRotMatrix(v1, R, _desiredVel);								if (isnan(_desiredVel[0]))				{					cout << "7a NAN vel " << endl;					quitWithMsg("NAN");				}			}			break;		case Agent::DRIVE_HUNGER:			quitWithMsg("Prey tried for hunting cog");			break;		default:			quitWithMsg("Unrecognized frustration type");	}		//Maintain desired speed	GLfloat desiredSpeed = _speed * gSettings.speedScalar * max(_dominantFrustration * 5.0f, 1.0f);	vecSetLength(_desiredVel, desiredSpeed);		//Drag by the drift velocity and combine with the target velocity	for (int j = 0; j < 3; j++)		_actualVel[j] = (_actualVel[j] * gSettings.driftDrag + _desiredVel[j]) / (gSettings.driftDrag + 1.0);		//Update the location based on the velocity	_loc[0] += _actualVel[0] * secsTranspired;	_loc[1] += _actualVel[1] * secsTranspired;	_loc[2] += _actualVel[2] * secsTranspired;		if (isnan(_desiredVel[0]))	{		cout << "NAN vel " << idx << endl;		quitWithMsg("NAN");	}		//Update the body animation	if (gSettings.bodyAnimationEnabled)	{		GLfloat tailSpeed = desiredSpeed * secsTranspired * 3.0;		_tailPos += _tailMovingForward ? tailSpeed : -tailSpeed;		if (_tailPos > 1.0)		{			_tailPos = 1.0;			_tailMovingForward = false;		}		else if (_tailPos < -1.0)		{			_tailPos = -1.0;			_tailMovingForward = true;		}	}}