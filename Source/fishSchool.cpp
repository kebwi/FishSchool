#include <stdio.h>#include <stdlib.h>#include <sys/time.h>#include <time.h>#include <math.h>#include <iostream>#include <sstream>#include <vector>#include <string>#include <utility>	//for pair<>#include <sys/stat.h>#ifdef __MACH__	//Building on a Mac	#include <GLUT/glut.h>#else	//Presumably building on Linux	#include <GL/glew.h>	#include <GL/glext.h>	#include <GL/gl.h>	#include <GL/glut.h>#endif#include "Random.h"#include "MathStuff.h"#include "smallStructs.h"#include "screengrab/screengrab.h"#include "Prey.h"#include "Predator.h"using namespace std;//======================================================================//Constsstatic const long skThirtiethSecMs = 1000 / 30;static const char kGLSLvertexShader[] = "GLSL/vAngularFisheye.glsl";static const char kGLSLfragmentShader[] = "GLSL/fFogAndEdgeFade.glsl";static const GLdouble kOrthoEdge = 1000.0;static const GLdouble kOrthoL = -kOrthoEdge;static const GLdouble kOrthoR = kOrthoEdge;static const GLdouble kOrthoB = -kOrthoEdge;static const GLdouble kOrthoT = kOrthoEdge;static const GLdouble kNearEdge = .001;static const GLdouble kFarEdge = 1.0;static const GLfloat kLightPos[4] = { .5f, 1.0f, 0.0f, 1.0f };	//Originalstatic const GLfloat kBGColor[4] = { 0.0, 0.0, 0.0, 1.0 };static const float kGridMaterialColor[] = { 1.0f, 1.0f, 1.0f, 1.0f };static const float kGridMaterialSpecular[]  = { 0.0f, 0.0f, 0.0f, 1.0f };static const float kGridMaterialShininess[] = { 100.0f };//======================================================================//Extern Global variables//======================================================================//Global variablesSettings gSettings;vector<Prey*> gPrey;vector<Predator*> gPredators;//======================================================================//Function prototypesvoid checkError(GLint status, const char *msg){	if (!status)	{		cerr << msg << endl;		exit(EXIT_FAILURE);	}}void quit(){	cout << endl;		for (int i = 0; i < gSettings.numPrey; i++)		delete gPrey[i];	gPrey.clear();		for (int i = 0; i < gSettings.numPredators; i++)		delete gPredators[i];	gPredators.clear();		exit(EXIT_SUCCESS);}void quitWithMsg(const char* msg){	cout << endl << msg << endl;		for (int i = 0; i < gSettings.numPrey; i++)		delete gPrey[i];	gPrey.clear();		for (int i = 0; i < gSettings.numPredators; i++)		delete gPredators[i];	gPredators.clear();		exit(EXIT_FAILURE);}//======================================================================static void writeDirectionsAndParameters(){	cout.precision(3);		cout << endl << endl;		cout << "Keys                  Variables                 Values" << endl << endl;		cout << " === CAMERA AND PROGRAM CONTROLS ===============" << endl << endl;		cout << "esc Quit" << endl;	cout << "spc Pause/unpause ----------------------------- " << (gSettings.pause ? "On" : "Off") << endl;	cout << "`   Screen capture to \"FlockScreenCapture.tga\"" << endl;	cout << "~   Continuous screen capture on/off ---------- " << (gSettings.captureScreenSequence ? "On" : "Off") << endl;	cout << "j l Camera yaw -------------------------------- " << gSettings.cameraYaw << endl;	cout << "i k Camera pitch ------------------------------ " << gSettings.cameraPitch << endl;	cout << "u o Camera roll ------------------------------- " << gSettings.cameraPitch << endl;	cout << "- = Camera zoom ------------------------------- " << gSettings.cameraZoom << endl;	cout << "p   Reset yaw, pitch, roll, zoom" << endl;	cout << "[   Fog on/off -------------------------------- " << ((gSettings.fogEnabled == 1) ? "On" : "Off") << endl;	cout << "]   Angular fisheye/hemispherical projection -- " << ((gSettings.angularFisheyeEnabled == 1) ? "AF" : "HS") << " (disabled)" << endl;	cout << "' \" Edge fade width (fraction of view radius) - " << gSettings.fadeWidthNormalized << endl;	cout << "\\   Vertex complexity distance scaling on/off - " << (gSettings.distanceVertexComplexityScalingEnabled ? "On" : "Off") << endl;	cout << "|   Body animation on/off --------------------- " << (gSettings.bodyAnimationEnabled ? "On" : "Off") << endl;	cout << "}   Colors to show frustration type on/off ---- " << (gSettings.showFrustration ? "On" : "Off") << endl << endl;		cout << " === WORLD =====================================" << endl << endl;		cout << ";   Show/hide world sphere (demo AF vs HS) ---- " << ((gSettings.showWorldSphere == 1) ? "On" : "Off") << endl;	cout << "a A Global speed scalar ----------------------- " << gSettings.speedScalar << endl;	cout << "s S Pred max tracked neighbors (prey always " << Prey::skMaxNeighborsPrey << ") " << ((Prey::skMaxNeighborsPrey <= 9) ? " " : "") << Predator::sMaxNeighborsPredator << endl;	cout << "d D Min agent acceptable distance ------------- " << sqrt(Agent::sAvoidanceDistSquared) << endl;	cout << "f F Desired neighbor distance ----------------- " << sqrt(Prey::sNearestNeighborDistanceSquared) << endl << endl;		cout << " === BEHAVIOR (ATTRACTIONS AND REPULSIONS) =====" << endl << endl;		cout << "z Z World center attraction ------------------- " << Agent::sWorldCenterStrength << endl;	cout << "x X Prey swarm COG attraction (pred always 0) - " << Prey::sSchoolCOGStrength << endl;	cout << "c C Neighbors COG attraction ------------------ " << Agent::sNeighborCogStrength << endl;	cout << "v V Prey nearest neighbor attraction ---------- " << Prey::sNearestNeighborStrength << endl;	cout << "b B Neighbors travel direction match attraction " << Agent::sNeighborVelocityStrength << endl;	cout << "n N Agent too close avoidance repulsion ------- " << Agent::sAvoidanceStrength << endl;	cout << "m M Predator hunger --------------------------- " << Predator::sPredatorHungerStrength << endl;	cout << ", . Prey evasiveness -------------------------- " << Prey::sPreyEvasionStrength << endl << endl;		cout << endl;}static char* readShaderSource(const char* shaderFile){	struct stat statBuf;	FILE* fp = fopen(shaderFile, "r");	char* buf;	stat(shaderFile, &statBuf);	buf = (char*) malloc((statBuf.st_size + 1) * sizeof(char));	fread(buf, 1, statBuf.st_size, fp);	buf[statBuf.st_size] = '\0';	fclose(fp);	return buf;}static inline float getTime(){	timeval tp;	gettimeofday(&tp, NULL);	return (tp.tv_sec % 10000) * 1000 + (tp.tv_usec / 1000);}static void init(){	cout << "Flocking simulation rendered with a glsl vertex shader and fragment shader that perform an angular fisheye projection and fog." << endl;	cout << "Keith Wiley, http://keithwiley.com, kwiley@keithwiley.com" << endl << endl;		cout << "There are two agent species: fast predators and slow prey.  Each agent attempts to swim/fly toward attractor locations, away from detractor locations, and attempts to align its direction of travel with its neighbors." << endl << endl;		cout << "These parameters, as well as some others, can be controlled using key commands." << endl << endl;		cout << "As agents become frustrated, due to a dissatisfaction with their present location with respect to their attractor and repulsor drives.  The effect of frustration is a temporary increase in speed (to attempt to satisfy the attractors and repulsors and thus reduce the frustration)." << endl << endl;		cout << "The framerate is output continuously to the terminal while the simulation is running." << endl;		//======================================================================================================================		glClearColor(kBGColor[0], kBGColor[1], kBGColor[2], kBGColor[3]);	glMatrixMode(GL_PROJECTION);	glLoadIdentity();	if (gSettings.useShader)		glFrustum(kOrthoL, kOrthoR, kOrthoB, kOrthoT, kNearEdge, kFarEdge);	else gluPerspective(120, 1, .1, 100);		glMatrixMode(GL_MODELVIEW);	glLoadIdentity();	glLightfv(GL_LIGHT0, GL_POSITION, kLightPos);	glEnable(GL_LIGHTING);	glEnable(GL_LIGHT0);		glEnable(GL_DEPTH_TEST);	glDepthFunc(GL_LESS);		if (gSettings.useShader)	{		glEnable(GL_FOG);		glFogi(GL_FOG_MODE, GL_LINEAR);	//GL_EXP, GL_EXP2, GL_LINEAR		glFogfv(GL_FOG_COLOR, kBGColor);		glFogf(GL_FOG_DENSITY, 0.9);	//Only applies to exponential and double exponential fog, not linear fog		glFogf(GL_FOG_START, gSettings.worldBounds * .25);		glFogf(GL_FOG_END, gSettings.worldBounds * 1.25);		glHint(GL_FOG_HINT, GL_NICEST);	//GL_DONT_CARE, GL_NICEST	}		for (int i = 0; i < gSettings.numPrey; i++)		gPrey.push_back(new Prey());		for (int i = 0; i < gSettings.numPredators; i++)		gPredators.push_back(new Predator());		//Init the time	gSettings.timeOfLastTimerMilliSecs = getTime();}static void initShader(const char* vShaderFile, const char* fShaderFile){	GLint status = (glGetError() == GL_NO_ERROR); 	char *vSource, *fSource;	GLuint vShader, fShader;	// read shader files	vSource = readShaderSource(vShaderFile);	checkError(status, "Failed to read vertex shader");	fSource = readShaderSource(fShaderFile);	checkError(status, "Failed to read fragment shader");	// create program and shader objects	vShader = glCreateShader(GL_VERTEX_SHADER);	fShader = glCreateShader(GL_FRAGMENT_SHADER);	gSettings.shaderProgram = glCreateProgram();	// attach shaders to the program object	glAttachShader(gSettings.shaderProgram, vShader);	glAttachShader(gSettings.shaderProgram, fShader);	// read shaders	glShaderSource(vShader, 1, (const char**) &vSource, NULL);	glShaderSource(fShader, 1, (const char**) &fSource, NULL);	// compile shaders	glCompileShader(vShader);	glCompileShader(fShader);	// error check	glGetShaderiv(vShader, GL_COMPILE_STATUS, &status);	checkError(status, "Failed to compile the vertex shader.");	glGetShaderiv(fShader, GL_COMPILE_STATUS, &status);	checkError(status, "Failed to compile the fragment shader.");	// link	glLinkProgram(gSettings.shaderProgram);	glGetShaderiv(gSettings.shaderProgram, GL_LINK_STATUS, &status);	checkError(status, "Failed to link the shader gSettings.shaderProgram object.");	// use program object	glUseProgram(gSettings.shaderProgram);	// set up uniform parameter	gSettings.timeParam = glGetUniformLocation(gSettings.shaderProgram, "gTimeParam");	gSettings.zoomParam = glGetUniformLocation(gSettings.shaderProgram, "gZoom");	gSettings.angularFisheyeParam = glGetUniformLocation(gSettings.shaderProgram, "gAngularFisheye");	gSettings.fogEnabledParam = glGetUniformLocation(gSettings.shaderProgram, "gFogEnabled");		gSettings.windowMinWidthHeightParam = glGetUniformLocation(gSettings.shaderProgram, "gSettings.windowMinWidthHeight");	gSettings.windowHalfMinWidthHeightParam = glGetUniformLocation(gSettings.shaderProgram, "gSettings.windowHalfMinWidthHeight");	gSettings.windowHalfMinWidthHeightSquaredParam = glGetUniformLocation(gSettings.shaderProgram, "gSettings.windowHalfMinWidthHeightSquared");		gSettings.fadeWidthParam = glGetUniformLocation(gSettings.shaderProgram, "gFadeWidth");	gSettings.fadeWidthSquaredParam = glGetUniformLocation(gSettings.shaderProgram, "gSettings.fadeWidthSquared");	gSettings.fadeWidthNormalizedParam = glGetUniformLocation(gSettings.shaderProgram, "gSettings.fadeWidthNormalized");	gSettings.fullFadeInDistParam = glGetUniformLocation(gSettings.shaderProgram, "gSettings.fullFadeInDist");	gSettings.fullFadeInDistSquaredParam = glGetUniformLocation(gSettings.shaderProgram, "gSettings.fullFadeInDistSquared");}static void draw(void){	if (gSettings.useShader)	{		glUniform1f(gSettings.timeParam, glutGet(GLUT_ELAPSED_TIME));		glUniform1f(gSettings.zoomParam, gSettings.cameraZoom);		glUniform1i(gSettings.angularFisheyeParam, gSettings.angularFisheyeEnabled ? (GLuint)1 : (GLuint)0);		glUniform1i(gSettings.fogEnabledParam, gSettings.fogEnabled ? (GLuint)1 : (GLuint)0);				//Not presently used //glUniform1f(gWindowMinWidthHeightParam, gSettings.windowMinWidthHeight);		glUniform1f(gSettings.windowHalfMinWidthHeightParam, gSettings.windowHalfMinWidthHeight);		//Not presently used //glUniform1f(gWindowHalfMinWidthHeightSquaredParam, gSettings.windowHalfMinWidthHeightSquared);				glUniform1f(gSettings.fadeWidthParam, gSettings.fadeWidth);		glUniform1f(gSettings.fadeWidthSquaredParam, gSettings.fadeWidthSquared);		glUniform1f(gSettings.fadeWidthNormalizedParam, gSettings.fadeWidthNormalized);		glUniform1f(gSettings.fullFadeInDistParam, gSettings.fullFadeInDist);		glUniform1f(gSettings.fullFadeInDistSquaredParam, gSettings.fullFadeInDistSquared);	}		glMatrixMode(GL_MODELVIEW);	glLoadIdentity();	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	glEnable (GL_BLEND);	glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);	glFrontFace(GL_CW);	glEnable(GL_DEPTH_TEST);	glDepthFunc(GL_LESS);		if (!gSettings.useShader)	{		if (gSettings.fogEnabled)		{			glFogi(GL_FOG_MODE, GL_LINEAR);			glFogfv(GL_FOG_COLOR, kBGColor);			glFogf(GL_FOG_DENSITY, 0.35f);			glHint(GL_FOG_HINT, GL_DONT_CARE);			glFogf(GL_FOG_START, 0);			glFogf(GL_FOG_END, fabs(gSettings.worldCenter[2]) * 2.5);			glEnable(GL_FOG);		}		else glDisable(GL_FOG);	}	    //==========================================================================================================        if (!gSettings.showFrustration)		glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, Prey::skMaterialColor);	glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, Agent::skMaterialSpecular);	glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, Agent::skMaterialShininess);		for (int i = 0; i < gSettings.numPrey; i++)		gPrey[i]->draw();	    //==========================================================================================================		if (!gSettings.showFrustration)		glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, Predator::skMaterialColor);	glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, Agent::skMaterialSpecular);	glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, Agent::skMaterialShininess);		for (int i = 0; i < gSettings.numPredators; i++)		gPredators[i]->draw();	    //==========================================================================================================        //Draw a sphere that spans the world to show that the radii are evenly spaced by the angular fisheye projection	if (gSettings.showWorldSphere)	{		glPushMatrix();						glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, kGridMaterialColor);			glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, kGridMaterialSpecular);			glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, kGridMaterialShininess);						//Rotate camera			glRotatef(gSettings.cameraYaw, 0.0, 1.0, 0.0);			glRotatef(gSettings.cameraPitch, 1.0, 0.0, 0.0);			glRotatef(gSettings.cameraPitch, 0.0, 0.0, 1.0);						glTranslatef(0.01, 0.01, 0.0);			glutWireSphere(1000.0, 32, 32);					glPopMatrix();	}    	glFrontFace(GL_CCW);		glutSwapBuffers();}static void reshape(int w, int h){	glMatrixMode(GL_PROJECTION);	glLoadIdentity();	if (gSettings.useShader)		glFrustum(kOrthoL, kOrthoR, kOrthoB, kOrthoT, kNearEdge, kFarEdge);	else gluPerspective(120, 1, .1, 100);		glMatrixMode(GL_MODELVIEW);	glLoadIdentity();		gSettings.windowMinWidthHeight = min(w, h);	//Force a square image instead of a rectangle that matches the window		cout << "New window dimensions: " << w << " x " << h << endl;		gSettings.windowHalfMinWidthHeight = gSettings.windowMinWidthHeight / 2;	gSettings.windowHalfMinWidthHeightSquared = gSettings.windowHalfMinWidthHeight * gSettings.windowHalfMinWidthHeight;	gSettings.fullFadeInDist = gSettings.windowHalfMinWidthHeight - gSettings.fadeWidth;	gSettings.fullFadeInDistSquared = gSettings.fullFadeInDist * gSettings.fullFadeInDist;	gSettings.fadeWidthNormalized = gSettings.fadeWidth / gSettings.windowHalfMinWidthHeight;		glViewport(0, 0, (int)gSettings.windowMinWidthHeight, (int)gSettings.windowMinWidthHeight);		glutPostRedisplay();}static void updateWorld(long millSecsTranspired){	if (gSettings.pause)		return;		//Get the seconds transpired	double secsTranspired = (double)millSecsTranspired / 1000.0;		//Find the center of gravity	GLfloat preyCog[3] = { 0.0, 0.0, 0.0 };	for (int i = 0; i < gSettings.numPrey; i++)		vecAdd(preyCog, gPrey[i]->_loc);	GLfloat scalar = 1.0 / (gSettings.numPrey);	vecScale(preyCog, scalar);		//Update the agents' velocities and locations	for (int i = 0; i < gSettings.numPrey; i++)		gPrey[i]->update(i, gPrey, gPredators, preyCog, secsTranspired);		for (int i = 0; i < gSettings.numPredators; i++)		gPredators[i]->update(i, gPrey, gPredators, preyCog, secsTranspired);}static void idle(){	//Get the time	long presentTimeMilliSecs = getTime();	long timeSinceLastTimerMilliSecs = presentTimeMilliSecs - gSettings.timeOfLastTimerMilliSecs;		//Update the framerate	gSettings.numFramesThisSec++;	if (presentTimeMilliSecs - gSettings.timeLastFPSSecStarted >= 1000)	{		gSettings.timeLastFPSSecStarted = presentTimeMilliSecs;			gSettings.numFramesLastSec = gSettings.numFramesThisSec;		gSettings.numFramesThisSec = 0;		cout << gSettings.numFramesLastSec << " " << flush;	}		//Update the world	if (!gSettings.captureScreenSequence)		updateWorld(timeSinceLastTimerMilliSecs);	else updateWorld(skThirtiethSecMs);	//Simulate perfect 30 fps when capturing a sequence, regardless of the actual framerate		//Draw the world	draw();		//Update the timer	gSettings.timeOfLastTimerMilliSecs = presentTimeMilliSecs;		gSettings.frameCount++;		//If autocapturing a sequence (to make an movie of the simulation), save the new frame to a targa image file	if (gSettings.captureScreenSequence)	{		string filename = "./ScreenSequenceCapture/";				if (gSettings.screenCaptureCount < 10000)			filename += "0";		if (gSettings.screenCaptureCount < 1000)			filename += "0";		if (gSettings.screenCaptureCount < 100)			filename += "0";		if (gSettings.screenCaptureCount < 10)			filename += "0";				stringstream ss;		ss << gSettings.screenCaptureCount++;		filename += ss.str();				filename += ".tga";				SaveScreenGrab(filename.c_str(), true, gSettings.windowMinWidthHeight, gSettings.windowMinWidthHeight);	}}static void timer(int val){	//It is important to reset the timer before doing work in this function.	//Reseting the timer at the bottom of the function will produce a slower than intended	//timer firing rate since the time spent in this function won't count if the timer is	//at the bottom of this function (it will count if it is reset at the top though).	if (!gSettings.pause)		glutTimerFunc(skThirtiethSecMs, timer, 0);		idle();}static void keyboard(unsigned char key, int x, int y){	switch (key)	{		//Control		case 27:	//esc			quit();			break;		case ' ':			gSettings.pause = !gSettings.pause;			writeDirectionsAndParameters();			if (gSettings.pause)			{				glutIdleFunc(NULL);			}			else			{				gSettings.timeOfLastTimerMilliSecs = getTime();								//glutTimerFunc(skThirtiethSecMs, timer, 0);				glutIdleFunc(idle);			}			break;		case '`':			SaveScreenGrab("./ScreenCaptures/FlockScreenCaptureRLE.tga", true, gSettings.windowMinWidthHeight, gSettings.windowMinWidthHeight);			break;		case '1':			SaveScreenGrab("./ScreenCaptures/FlockScreenCapture.tga", false, gSettings.windowMinWidthHeight, gSettings.windowMinWidthHeight);			break;		case '~':			gSettings.captureScreenSequence = !gSettings.captureScreenSequence;			writeDirectionsAndParameters();			break;		case '|':			gSettings.bodyAnimationEnabled = !gSettings.bodyAnimationEnabled;			writeDirectionsAndParameters();			glutPostRedisplay();			break;		case '}':			gSettings.showFrustration = !gSettings.showFrustration;			writeDirectionsAndParameters();			glutPostRedisplay();			break;				//Camera controls		case 'j':			gSettings.cameraYaw += gSettings.cameraRotAmt;			if (gSettings.cameraYaw > 360.0)				gSettings.cameraYaw -= 360.0;			writeDirectionsAndParameters();			glutPostRedisplay();			break;		case 'l':			gSettings.cameraYaw -= gSettings.cameraRotAmt;			if (gSettings.cameraYaw < 0.0)				gSettings.cameraYaw += 360.0;			writeDirectionsAndParameters();			glutPostRedisplay();			break;		case 'i':			gSettings.cameraPitch += gSettings.cameraRotAmt;			if (gSettings.cameraPitch > 360.0)				gSettings.cameraPitch -= 360.0;			writeDirectionsAndParameters();			glutPostRedisplay();			break;		case 'k':			gSettings.cameraPitch -= gSettings.cameraRotAmt;			if (gSettings.cameraPitch < 0.0)				gSettings.cameraPitch += 360.0;			writeDirectionsAndParameters();			glutPostRedisplay();			break;		case 'u':			gSettings.cameraPitch += gSettings.cameraRotAmt;			if (gSettings.cameraPitch > 360.0)				gSettings.cameraPitch -= 360.0;			writeDirectionsAndParameters();			glutPostRedisplay();			break;		case 'o':			gSettings.cameraPitch -= gSettings.cameraRotAmt;			if (gSettings.cameraPitch < 0.0)				gSettings.cameraPitch += 360.0;			writeDirectionsAndParameters();			glutPostRedisplay();			break;		case 'p':			gSettings.cameraYaw = gSettings.cameraPitch = gSettings.cameraPitch = 0.0;			gSettings.cameraZoom = 1.0;			writeDirectionsAndParameters();			glutPostRedisplay();			break;		case '-':			gSettings.cameraZoom *= .8;			writeDirectionsAndParameters();			glutPostRedisplay();			break;		case '=':			gSettings.cameraZoom *= 1.25;			writeDirectionsAndParameters();			glutPostRedisplay();			break;		case '[':			gSettings.fogEnabled = (gSettings.fogEnabled == 0) ? 1 : 0;			writeDirectionsAndParameters();			glutPostRedisplay();			break;		case ']':			gSettings.angularFisheyeEnabled = (gSettings.angularFisheyeEnabled == 0) ? 1 : 0;			writeDirectionsAndParameters();			glutPostRedisplay();			break;		case ';':			gSettings.showWorldSphere = !gSettings.showWorldSphere;			writeDirectionsAndParameters();			glutPostRedisplay();			break;		case '\'':			gSettings.fadeWidth -= 25.0;			if (gSettings.fadeWidth < 0)				gSettings.fadeWidth = 0;			gSettings.fadeWidthSquared = gSettings.fadeWidth * gSettings.fadeWidth;			gSettings.fadeWidthNormalized = gSettings.fadeWidth / gSettings.windowHalfMinWidthHeight;			gSettings.fullFadeInDist = gSettings.windowHalfMinWidthHeight - gSettings.fadeWidth;			gSettings.fullFadeInDistSquared = gSettings.fullFadeInDist * gSettings.fullFadeInDist;			writeDirectionsAndParameters();			glutPostRedisplay();			break;		case '"':			gSettings.fadeWidth += 25.0;			if (gSettings.fadeWidth > gSettings.windowHalfMinWidthHeight)				gSettings.fadeWidth = gSettings.windowHalfMinWidthHeight;				gSettings.fadeWidthSquared = gSettings.fadeWidth * gSettings.fadeWidth;			gSettings.fadeWidthNormalized = gSettings.fadeWidth / gSettings.windowHalfMinWidthHeight;			gSettings.fullFadeInDist = gSettings.windowHalfMinWidthHeight - gSettings.fadeWidth;			gSettings.fullFadeInDistSquared = gSettings.fullFadeInDist * gSettings.fullFadeInDist;			writeDirectionsAndParameters();			glutPostRedisplay();			break;		case '\\':			gSettings.distanceVertexComplexityScalingEnabled = !gSettings.distanceVertexComplexityScalingEnabled;			writeDirectionsAndParameters();			glutPostRedisplay();			break;				//Settings		case 'A':			gSettings.speedScalar *= 2.0;			writeDirectionsAndParameters();			break;		case 'a':			gSettings.speedScalar /= 2.0;			if (gSettings.speedScalar < .125)				gSettings.speedScalar = .125;			writeDirectionsAndParameters();			break;		case 'S':			Predator::sMaxNeighborsPredator++;			writeDirectionsAndParameters();			break;		case 's':			Predator::sMaxNeighborsPredator--;			if (Predator::sMaxNeighborsPredator < 0)				Predator::sMaxNeighborsPredator = 0;			writeDirectionsAndParameters();			break;		case 'D':			{				GLfloat n = sqrt(Agent::sAvoidanceDistSquared);				n += 1.0;				Agent::sAvoidanceDistSquared = n * n;				writeDirectionsAndParameters();			}			break;		case 'd':			{				GLfloat n = sqrt(Agent::sAvoidanceDistSquared);				n -= 1.0;				if (n < 0.0)					n = 0.0;				Agent::sAvoidanceDistSquared = n * n;				writeDirectionsAndParameters();			}			break;		case 'F':			{				GLfloat n = sqrt(Prey::sNearestNeighborDistanceSquared);				n += 1.0;				Prey::sNearestNeighborDistanceSquared = n * n;				writeDirectionsAndParameters();			}			break;		case 'f':			{				GLfloat n = sqrt(Prey::sNearestNeighborDistanceSquared);				n -= 1.0;				if (n < 0.0)					n = 0.0;				Prey::sNearestNeighborDistanceSquared = n * n;				writeDirectionsAndParameters();			}			break;		case 'Z':			Agent::sWorldCenterStrength += 5.0;			if (Agent::sWorldCenterStrength > 100.0)				Agent::sWorldCenterStrength = 100.0;			writeDirectionsAndParameters();			break;		case 'z':			Agent::sWorldCenterStrength -= 5.0;			if (Agent::sWorldCenterStrength < 0.0)				Agent::sWorldCenterStrength = 0.0;			writeDirectionsAndParameters();			break;		case 'X':			Prey::sSchoolCOGStrength += 5.0;			if (Prey::sSchoolCOGStrength > 100.0)				Prey::sSchoolCOGStrength = 100.0;			writeDirectionsAndParameters();			break;		case 'x':			Prey::sSchoolCOGStrength -= 5.0;			if (Prey::sSchoolCOGStrength < 0.0)				Prey::sSchoolCOGStrength = 0.0;			writeDirectionsAndParameters();			break;		case 'C':			Agent::sNeighborCogStrength += 5.0;			if (Agent::sNeighborCogStrength > 100.0)				Agent::sNeighborCogStrength = 100.0;			writeDirectionsAndParameters();			break;		case 'c':			Agent::sNeighborCogStrength -= 5.0;			if (Agent::sNeighborCogStrength < 0.0)				Agent::sNeighborCogStrength = 0.0;			writeDirectionsAndParameters();			break;		case 'V':			Prey::sNearestNeighborStrength += 5.0;			if (Prey::sNearestNeighborStrength > 100.0)				Prey::sNearestNeighborStrength = 100.0;			writeDirectionsAndParameters();			break;		case 'v':			Prey::sNearestNeighborStrength -= 5.0;			if (Prey::sNearestNeighborStrength < 0.0)				Prey::sNearestNeighborStrength = 0.0;			writeDirectionsAndParameters();			break;		case 'B':			Agent::sNeighborVelocityStrength += 5.0;			if (Agent::sNeighborVelocityStrength > 100.0)				Agent::sNeighborVelocityStrength = 100.0;			writeDirectionsAndParameters();			break;		case 'b':			Agent::sNeighborVelocityStrength -= 5.0;			if (Agent::sNeighborVelocityStrength < 0.0)				Agent::sNeighborVelocityStrength = 0.0;			writeDirectionsAndParameters();			break;		case 'N':			Agent::sAvoidanceStrength += 5.0;			if (Agent::sAvoidanceStrength > 100.0)				Agent::sAvoidanceStrength = 100.0;			writeDirectionsAndParameters();			break;		case 'n':			Agent::sAvoidanceStrength -= 5.0;			if (Agent::sAvoidanceStrength < 0.0)				Agent::sAvoidanceStrength = 0.0;			writeDirectionsAndParameters();			break;		case 'M':			Predator::sPredatorHungerStrength += 5.0;			if (Predator::sPredatorHungerStrength > 100.0)				Predator::sPredatorHungerStrength = 100.0;			writeDirectionsAndParameters();			break;		case 'm':			Predator::sPredatorHungerStrength -= 5.0;			if (Predator::sPredatorHungerStrength < 0.0)				Predator::sPredatorHungerStrength = 0.0;			writeDirectionsAndParameters();			break;		case '<':			Prey::sPreyEvasionStrength += 5.0;			if (Prey::sPreyEvasionStrength > 100.0)				Prey::sPreyEvasionStrength = 100.0;			writeDirectionsAndParameters();			break;		case ',':			Prey::sPreyEvasionStrength -= 5.0;			if (Prey::sPreyEvasionStrength < 0.0)				Prey::sPreyEvasionStrength = 0.0;			writeDirectionsAndParameters();			break;				default:			break;	}}int main(int argc, char** argv){	cout << "Default prey population is " << gSettings.numPrey << "." << endl;	cout << "To use a different population, enter it as the first argument to the program." << endl;	cout << "The predator population is always " << gSettings.numPredators << "." << endl;		if (argc > 1)	{		gSettings.numPrey = atoi(argv[1]);		cout << "Overriding default prey population and using " << gSettings.numPrey << " instead." << endl;	}	cout << endl;		SeedRandom();		glutInit(&argc, argv);	glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH);	glutInitWindowSize((int)gSettings.windowMinWidthHeight, (int)gSettings.windowMinWidthHeight);	glutInitWindowPosition(5, 5);	glutCreateWindow("Angular Fisheye Dome Flocking");	glutDisplayFunc(draw);	glutReshapeFunc(reshape);	//glutIdleFunc(idle);	//This would make the simulation run as fast as possible	if (!gSettings.pause)		glutTimerFunc(skThirtiethSecMs, timer, 0);	//Run the simulation at a fixed maximum rate of skThirtiethSecMs	glutKeyboardFunc(keyboard);	init();		writeDirectionsAndParameters();		if (gSettings.useShader)		initShader(kGLSLvertexShader, kGLSLfragmentShader);		glutMainLoop();		return 0;}