#ifndef __SMALL_STRUCTS__#define __SMALL_STRUCTS__#ifdef __MACH__	//Building on a Mac	#include <GLUT/glut.h>#else	//Presumably building on Linux	#include <GL/glew.h>	#include <GL/glext.h>	#include <GL/gl.h>	#include <GL/glut.h>#endif#include <math.h>struct Settings{	public:		bool useShader;				bool pause;		bool captureScreenSequence;		unsigned long screenCaptureCount;				GLfloat windowMinWidthHeight;	//Stupid to make this as a float, but the fragment shader can't do a typecast.		GLfloat windowHalfMinWidthHeight;		GLfloat windowHalfMinWidthHeightSquared;				GLuint shaderProgram;		GLuint windowMinWidthHeightParam;		GLuint windowHalfMinWidthHeightParam;		GLuint windowHalfMinWidthHeightSquaredParam;		GLint timeParam;		GLuint zoomParam;		GLuint angularFisheyeParam;		GLuint fogEnabledParam;		GLuint fadeWidthParam;		GLuint fadeWidthSquaredParam;		GLuint fadeWidthNormalizedParam;		GLuint fullFadeInDistParam;		GLuint fullFadeInDistSquaredParam;				long timeOfLastTimerMilliSecs;		long timeLastFPSSecStarted;		int numFramesThisSec;		int numFramesLastSec;		unsigned long frameCount;				int numPrey;		int numPredators;				GLfloat cameraYaw, cameraPitch, cameraRoll;		GLfloat cameraRotAmt;		GLfloat cameraZoom;				GLfloat worldCenter[3];		GLfloat worldBounds;				bool bodyAnimationEnabled;		bool distanceVertexComplexityScalingEnabled;		bool angularFisheyeEnabled;	//Otherwise hemispherical		bool fogEnabled;		GLfloat fadeWidth;	//Pixels		GLfloat fadeWidthSquared;		GLfloat fadeWidthNormalized;		GLfloat fullFadeInDist;		GLfloat fullFadeInDistSquared;		bool showWorldSphere;		bool showFrustration;				GLfloat speedScalar;		GLfloat driftDrag;	//More like momentum than drag actually.  The higher this is, the more strongly velocity (speed and direction) is preserved.			Settings() :		useShader(false),				pause(false),		captureScreenSequence(false),		screenCaptureCount(0),				windowMinWidthHeight(700),		windowHalfMinWidthHeight(windowMinWidthHeight / 2),		windowHalfMinWidthHeightSquared(windowHalfMinWidthHeight * windowHalfMinWidthHeight),				shaderProgram(0),		windowMinWidthHeightParam(0),		windowHalfMinWidthHeightParam(0),		windowHalfMinWidthHeightSquaredParam(0),		timeParam(0),		zoomParam(0),		angularFisheyeParam(0),		fogEnabledParam(0),		fadeWidthParam(0),		fadeWidthSquaredParam(0),		fadeWidthNormalizedParam(0),		fullFadeInDistParam(0),		fullFadeInDistSquaredParam(0),				timeOfLastTimerMilliSecs(0),		timeLastFPSSecStarted(0),		numFramesThisSec(0),		numFramesLastSec(0),		frameCount(0),				numPrey(98),		numPredators(2),				cameraYaw(0.0), cameraPitch(0.0), cameraRoll(0.0),		cameraRotAmt(2.0),		cameraZoom(1.0),				//worldCenter[0](0.0), worldCenter[1](0.0), worldCenter[2](-10.0),		//worldCenter(0.0, 0.0, -10.0),		//worldBounds(fabs(worldCenter[2]) * 2.0),				bodyAnimationEnabled(true),		distanceVertexComplexityScalingEnabled(false),		angularFisheyeEnabled(true),		fogEnabled(true),		fadeWidth(25.0),		fadeWidthSquared(fadeWidth * fadeWidth),		fadeWidthNormalized(fadeWidth / windowMinWidthHeight),		fullFadeInDist(windowHalfMinWidthHeight - fadeWidth),		fullFadeInDistSquared(fullFadeInDist * fullFadeInDist),		showWorldSphere(false),		showFrustration(false),				speedScalar(1.0),		driftDrag(9.0)	{		worldCenter[0] = 0.0;		worldCenter[1] = 0.0;		worldCenter[2] = (useShader ? -10.0 : -15.0);				worldBounds = fabs(worldCenter[2]) * 2.0;	}};#endif